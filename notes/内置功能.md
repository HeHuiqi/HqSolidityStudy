# 区块和交易属性
* `blockhash(uint blockNumber) returns (bytes32)`：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块,blockhash 函数之前是使用 block.blockhash， block.blockhash 在 0.4.22 开始不推荐使用，在 0.5.0 已经移除了
* `block.chainid (uint)`: 当前链 id
* `block.coinbase ( address )`: 挖出当前区块的矿工地址
* `block.difficulty ( uint )`: 当前区块难度
* `block.gaslimit ( uint )`: 当前区块 gas 限额
* `block.number ( uint )`: 当前区块号
* `block.timestamp ( uint)`: 自 unix epoch 起始当前区块以秒计的时间戳
* `gasleft() returns (uint256)` ：剩余的 gas
* `msg.data ( bytes )`: 完整的 calldata
* `msg.sender ( address )`: 消息发送者（当前调用）
* `msg.sig ( bytes4 )`: calldata 的前 4 字节（也就是函数标识符，即函数签名）
* `msg.value ( uint )`: 随消息发送的 wei 的数量，通常指交易的金额
* `tx.gasprice (uint)`: 交易的 gas 价格
* `tx.origin (address payable)`: 交易发起者（完全的调用链）

# ABI 编码及解码函数
* `abi.decode(bytes memory encodedData, (...)) returns (...)`: 对给定的数据进行ABI解码，而解码数据的类型保存在括号中第二个参数 。 例如: `(uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))`
* `abi.encode(...) returns (bytes)`： ABI - 对给定参数进行编码
* `abi.encodePacked(...) returns (bytes)`：对给定参数执行 紧打包编码 ，注意，可以不明确打包编码。
* `abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)`： ABI - 对函数签名以及参数编码并返回编码结果
* `abi.encodeWithSignature(string signature, ...) returns (bytes)`：等价于 abi.`encodeWithSelector(bytes4(keccak256(signature), ...)`

# 错误处理
* `assert(bool condition)` 如果不满足条件，则会导致Panic 错误，则撤销状态更改 - 用于检查内部错误。
* `require(bool condition)` 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。
* `require(bool condition, string memory message)` 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。
* `revert()` 终止运行并撤销状态更改。
* `revert(string memory reason)`
* 终止运行并撤销状态更改，可以同时提供一个解释性的字符串。

# 数学和密码学函数
* `addmod(uint x, uint y, uint k) returns (uint)`：计算 `(x + y) % k`，加法会在任意精度下执行，并且加法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。

* `mulmod(uint x, uint y, uint k) returns (uint)`： 计算 `(x * y) % k`，乘法会在任意精度下执行，并且乘法的结果即使超过 `2**256` 也不会被截取。从 0.5.0 版本的编译器开始会加入对 `k != 0` 的校验（assert）。

* `keccak256((bytes memory) returns (bytes32)`：计算 Keccak-256 哈希。

* `sha256(bytes memory) returns (bytes32)`：计算参数的 SHA-256 哈希。

* `ripemd160(bytes memory) returns (bytes20)`：计算参数的 RIPEMD-160 哈希。

* `ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)`：
利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。
函数参数对应于 ECDSA签名的值:
    * `r` = 签名的前 32 字节
    * `s` = 签名的第2个32 字节
    * `v` = 签名的最后一个字节
`ecrecover` 返回一个 `address`, 而不是 `address payable `。他们之前的转换参考 [address payable](https://learnblockchain.cn/docs/solidity/types.html#address)

合约相关:

`this (current contract’s type)`: 当前合约，明确可转换 `address` 或 `address payable`
`super`: 继承层次结构中高一级的合约
`selfdestruct(address payable recipient)`: 销毁当前合同，将其资金发送到给定地址
`<address>.balance (uint256)`: 地址的余额
`<address>.code (bytes memory)`: code at the 地址类型 Address (can be empty)
`<address>.codehash (bytes32)`: the codehash of the 地址类型 Address
`<address payable>.send(uint256 amount) returns (bool)`: send given amount of Wei to 地址类型 Address, returns false on failure
`<address payable>.transfer(uint256 amount)`: send given amount of Wei to 地址类型 Address, throws on failure


类型信息:
表达式 `type(X)` 可用于检索参数 `X` 的类型信息

用于合约类型 `C` 有以下属性:
* `type(C).name`:获得合约名
* `type(C).creationCode`:获得包含创建合同字节码的内存字节数组。它可以在内联汇编中构建自定义创建例程，尤其是使用 `create2` 操作码。 不能在合同本身或派生的合同访问此属性。 因为会引起循环引用.

`type(C).runtimeCode`:获得合同的运行时字节码的内存字节数组。这是通常由 `C` 的构造函数部署的代码。 如果 `C` 有一个使用内联汇编的构造函数，那么可能与实际部署的字节码不同。 还要注意库在部署时修改其运行时字节码以防范定期调用（guard against regular calls）。 与 `.creationCode` 有相同的限制，不能在合同本身或派生的合同访问此属性。 因为会引起循环引用。

接口类型 `I`有以下属性：
`type(I).interfaceId`:返回接口 `I` 的 bytes4 类型的接口 ID，接口 ID 参考[EIP-165](https://learnblockchain.cn/docs/eips/eip-165.html) 定义的， 接口 ID 被定义为 `XOR` （异或） 接口内所有的函数的函数选择器（除继承的函数。

对于整型 `T` 有以下属性：
`type(T).min`:`T`的最小值。
`type(T).max`: `T` 的最大值。